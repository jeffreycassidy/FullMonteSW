/* BaseLogger.hpp
 *
 *  Created on: Sep 28, 2016
 *      Author: jcassidy
 */

#ifndef KERNELS_SOFTWARE_LOGGER_BASELOGGER_HPP_
#define KERNELS_SOFTWARE_LOGGER_BASELOGGER_HPP_

#include "immintrin.h"
#include <utility>

class Packet;
class Tetra;

/** Logger Concept
 *
 * The Logger is a type that is passed into a simulation Kernel to record events via its eventXXX(...) methods.
 * An instance of a Logger will be called by a single execution thread of the kernel, so its methods need not be thread-safe.
 * Any accesses to other objects by a contained pointer or by reference, though, will need to be done in a thread-safe manner if
 * multiple Loggers could hold the same reference.
 *
 * The Logger should be created by a matching Scorer, which is responsible for creating Logger instances, and for packaging up the
 * resulting output.
 *
 * No virtual methods are used. To preserve performance, it is intended that all polymorphism occur at compile time (via templates)
 * instead of run time (virtual methods).
 *
 * Concept requirements
 *
 *		default constructible
 *		move constructible							(possibly by copying)
 *
 *		typedef Scorer								The Scorer type associated with this logger
 *
 * 		typedef State								Type that holds the state of the logger
 * 		void clear()								Clears the state
 * 		const State& state()						Returns the current state
 *
 * 		commit(AbstractScorer* S)					Post the results to an AbstractScorer
 *
 * 		implementation of all eventXXX(...) methods to handle events that are to be logged
 */

class AbstractScorer;

class BaseLogger
{
public:
	typedef std::true_type is_logger;

	BaseLogger(const BaseLogger&)=default;
	BaseLogger(BaseLogger&&)=default;							///< Movable


	/** Infrequently-called routines - default to no-op; derived classes may override if needed
	 */

	void clear();					///< Clear the state of this logger
	void commit(AbstractScorer*);	///< Commit the results to a parent Scorer



    /** All eventXXX(...) methods below are invoked within the simulation kernel. They should be optimized for speed,
     * and so should not use virtual calls if it can be avoided.
     *
     * Access to the Logger need not be thread-safe, since each thread gets its own private logger object.
     */

	typedef std::pair<__m128,__m128> 	Ray3;
	typedef __m128 						Point3;
	typedef __m128 						UVect3;

    inline void eventLaunch(AbstractScorer&,const Ray3 r,unsigned IDt,double w){};

    inline void eventBoundary(AbstractScorer&,const Point3 p,int,int,int){};        // boundary (same material)

    inline void eventAbsorb(AbstractScorer&,const Point3 p,unsigned IDt,double w0,double dw){};
    inline void eventScatter(AbstractScorer&,const UVect3 d0,const UVect3 d,double g){};

    inline void eventInterface(AbstractScorer&,const Ray3,int,unsigned){};          // found a material interface; possible results are:
    inline void eventRefract(AbstractScorer&,const Point3,UVect3){};                //      refracted
    inline void eventReflectInternal(AbstractScorer&,const Point3,const UVect3){};  //      internal reflection
    inline void eventReflectFresnel(AbstractScorer&,const Point3,UVect3){};         //      fresnel reflection

    inline void eventNewTetra(AbstractScorer&,const Packet& pkt,const Tetra& T0,const unsigned tetraFaceIndex){};
    	// packet pkt propagating from tetra T0 from face (tetraFaceIndex) 0..3

    // termination events
    inline void eventExit(AbstractScorer&,const Ray3,int,double){};            			// exited geometry
    inline void eventDie(AbstractScorer&,double){};                                     // lost Russian roulette
    inline void eventRouletteWin(AbstractScorer&,double,double){};

    inline void eventAbnormal(AbstractScorer&,const Packet&,unsigned,unsigned){};

    inline void eventTimeGate(AbstractScorer&,const Packet&){};						// Exceeded time gate
    inline void eventNoHit(AbstractScorer&,const Packet&,const Tetra&){};			// No hit in intersection

protected:
	BaseLogger();
	~BaseLogger();
};




#include <type_traits>

namespace Events {

/** For each invocation of DEFINE_EVENT(E), creates a tag type E_tag and an instance of that tag type E, as well as a
 * function that dispatches
 *
 * 		E					An event name
 * 		E_tag		(auto) 	Tag type generated by DEFINE_EVENT(E)
 * 		Events::E	(auto)	Instance of tag type generated by DEFINE_EVENT(E)
 *
 * 		Logger				Class fulfilling Logger concept
 * 		l					Instance of class L
 *
 * 		s					AbstractScorer* pointing to the corresponding Scorer
 *
 * log_event(l,E,...) will call l.eventE(s,...)
 */

#define DEFINE_EVENT(ename) typedef struct {} ename##_tag; \
	extern ename##_tag ename; \
	template<class Logger,class Scorer,typename... Args>inline typename std::enable_if< std::is_same<typename Logger::is_logger,std::true_type>::value,void>::type \
		log_event(Logger& l,Scorer& s,Events::ename##_tag,Args... args) \
		{ l.event##ename(s,args...); }

// Example instance
//DEFINE_EVENT(Launch) typedef struct {} Launch_tag;
//extern Launch_tag Launch;
//log_event(Logger& l, Events::E_tag, ...)
//{
//	l.eventLaunch(...);
//}

DEFINE_EVENT(Launch)
DEFINE_EVENT(Absorb)
DEFINE_EVENT(Scatter)
DEFINE_EVENT(Boundary)
DEFINE_EVENT(Interface)
DEFINE_EVENT(ReflectInternal)
DEFINE_EVENT(Refract)
DEFINE_EVENT(ReflectFresnel)
DEFINE_EVENT(Exit)
DEFINE_EVENT(NewTetra)
DEFINE_EVENT(RouletteWin)
DEFINE_EVENT(Die)
DEFINE_EVENT(Abnormal)
DEFINE_EVENT(TimeGate)
DEFINE_EVENT(NoHit)

}

#endif /* KERNELS_SOFTWARE_LOGGER_BASELOGGER_HPP_ */
