/*
 * Test_Placement.cpp
 *
 *  Created on: Mar 9, 2016
 *      Author: jcassidy
 */

#define BOOST_TEST_MODULE Test_Placement
#define BOOST_TEST_DYN_LINK

#include <boost/test/unit_test.hpp>

#include "PlanePlacementPencilBeam.hpp"

#include "VectorTest.hpp"

#include <FullMonteHW/Geometry/Sources/PencilBeam.hpp>
#include <FullMonteHW/Geometry/Sources/Print.hpp>

using namespace std;

BOOST_AUTO_TEST_CASE(pb)
{
	// the placement constraint
	PlanePlacement P;

	// the source description
	Source::PencilBeam PB0(1.0,std::array<float,3>{NAN,NAN,NAN},std::array<float,3>{NAN,NAN,NAN},-1U);
	Source::PencilBeam PB1(0.5,std::array<float,3>{NAN,NAN,NAN},std::array<float,3>{NAN,NAN,NAN},-1U);

	// the mediator
	PlanePlacementPencilBeam M0;
		M0.placement(&P);
		M0.source(&PB0);
		M0.planePosition(std::array<float,2>{1.0,2.0});

	PlanePlacementPencilBeam M1;
		M1.placement(&P);
		M1.source(&PB1);
		M1.planePosition(std::array<float,2>{-1.0,0.0});


	M0.update();
	M1.update();

	for(const auto* s : P.sources())
		cout << *s->source() << endl;

	P.basis().origin(std::array<float,3>{ 10.0f, 20.0f, 30.0f });



	for(const auto* s : P.sources())
		cout << *s->source() << endl;

	P.update();


	for(const auto* s : P.sources())
		cout << *s->source() << endl;

	P.basis() = Basis(
				UnitVector3{ 0.0f, 1.0f, 0.0f },
				UnitVector3{ 0.0f,0.0f,-1.0f },
				UnitVector3{ 1.0f, 0.0f, 0.0f },
				Point3{100.0f,100.0f,100.0f});

	P.update();

	for(const auto* s : P.sources())
		cout << *s->source() << endl;
}

#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkPolyDataWriter.h>

#include <FullMonteHW/Storage/TIMOS/TIMOSWriter.hpp>

BOOST_AUTO_TEST_CASE(knee905)
{
	Point3 source_posterior{ 55.67f, -67.5f, 135.45f 	};

	Point3 centre{ 53.7f, -59.7f, 135.3f 	};

	Point3 tibia { 53.7f, -59.7f, 160.6f	};

	Point3 femur { 50.32f, -58.6f, 117.5f };

	UnitVector3 dir = normalize(centre-source_posterior);

	UnitVector3 lat = normalize(cross(dir,centre-tibia));
	UnitVector3 up = cross(lat,dir);

	CHECK_ORTHONORMAL(dir,lat,up,1e-6f);

	// the placement constraint
	PlanePlacement P;

	// the source description
	std::vector<Source::PencilBeam> 		pbs(5);
	std::vector<PlanePlacementPencilBeam>	mediators(pbs.size());
	std::vector<Point2>						pbsPos{
		Point2{  0.0f ,  0.0f },
		Point2{  1.75f,  0.0f },
		Point2{ -1.75f,  0.0f },
		Point2{  0.0f , -1.75f},
		Point2{  0.0f ,  1.75f}
	};

	float r660 = sqrt(0.5f)*1.75f;
	std::vector<Point2>						pbsPos660{
		Point2{ r660, r660 },
		Point2{-r660, r660 },
		Point2{-r660,-r660 },
		Point2{ r660,-r660 }
	};

	for(unsigned i=0;i<pbs.size();++i)
	{
		mediators[i].placement(&P);
		mediators[i].source(&pbs[i]);
		mediators[i].planePosition(pbsPos[i]);
		mediators[i].update();
	}

	P.basis() = Basis(lat,up,dir,source_posterior);
	P.update();

	for(const auto* s : P.sources())
		cout << *s->source() << endl;

	//// Convert sources into polydata
	vtkPolyData* pd = vtkPolyData::New();
	vtkPoints* vtkP = vtkPoints::New();
	vtkCellArray* ca_lines = vtkCellArray::New();

	float l = 10.0f;

	// Convert pencil beam into line
	for (const Source::PencilBeam& pb : pbs)
	{
		vtkIdType IDps[2];

		IDps[0] = vtkP->InsertNextPoint(pb.position().data());
		IDps[1] = vtkP->InsertNextPoint((pb.position() + l*pb.direction()).data());
		ca_lines->InsertNextCell(2,IDps);
	}

	pd->SetPoints(vtkP);
	pd->SetLines(ca_lines);

	// write it out
	vtkPolyDataWriter *W = vtkPolyDataWriter::New();
		W->SetFileName("sources905.vtk");
		W->SetInputData(pd);
		W->Update();

	// write sources to TIM-OS format
	TIMOSWriter TW("foo");
	TW.setSourceFileName("test.source");
	TW.comment("Generated by Test_Placement(knee)");
	Source::Base *s = P.source();

	TW.write(s);
	delete s;

}
